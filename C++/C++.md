# C++ 语法

## 1.基本类型

## 2.枚举类型，类型命名

## 3.变量和常量

C++ 中有两种类型的表达式：

- 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量作用域：
在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。

初始化局部变量和全局变量
当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：

| 数据类型 | 初始化数据值 |
| :------: | :----------: |
| int      | ０           |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。

常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

在 C++ 中，有两种简单的定义常量的方式：

- 使用 #define 预处理器。
- 使用 const 关键字。

## 4.修饰符类型

C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。
下面列出了数据类型修饰符：

- signed
- unsigned
- long
- short

修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。

修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。

C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，
int 是隐含的.

C++ 中的类型限定符:

| 限定符   | 含义 |
| -------- | ----------------- |
| const    | const 类型的对象在程序执行期间不能被修改改变。|
| volatile | 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。
对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 |
| restrict | 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict|

## 5.C++ 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：

- auto
- register
- static
- extern
- mutable
- thread_local (C++11)

从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用

auto 存储类

自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。
C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。

register 存储类

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），
且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

static 存储类

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

extern 存储类

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，
会把变量名指向一个之前定义过的存储位置。
当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的
引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。
extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。

mutable 存储类

mutable 说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。

thread_local 存储类

使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

thread_local 说明符可以与 static 或 extern 合并。

可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。

## 6.运算符

- 算术运算符
    假设变量 A 的值为 10，变量 B 的值为 20：
    | 运算符 | 描述 | 实例 |
    | ------ | ---- | ---- |
    | +    |把两个操作数相加|A + B 将得到 30
    | -   |从第一个操作数中减去第二个操作数|A - B 将得到 -10
    | *    |把两个操作数相乘|A * B 将得到 200
    | /    |分子除以分母|B / A 将得到 2
    | %    |取模运算符，整除后的余数|B % A 将得到 0
    | ++    |自增运算符，整数值增加 1|A++ 将得到 11
    | --    |自减运算符，整数值减少 1|A-- 将得到 9

- 关系运算符
    假设变量 A 的值为 10，变量 B 的值为 20，则：

    |运算符 |描述|实例|
    |---|---|---|
    |==|检查两个操作数的值是否相等，如果相等则条件为真。|(A == B) 不为真。
    |!=|检查两个操作数的值是否相等，如果不相等则条件为真。|(A != B) 为真。
    |>|检查左操作数的值是否大于右操作数的值，如果是则条件为真。|(A > B) 不为真。
    |<|检查左操作数的值是否小于右操作数的值，如果是则条件为真。|(A < B) 为真。
    |>=|检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。|(A >= B) 不为真。
    |<=|检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。|(A <= B) 为真。

- 逻辑运算符
    假设变量 A 的值为 1，变量 B 的值为 0，则：

    |运算符|描述|实例|
    |---|---|---|
    |&&|称为逻辑与运算符。如果两个操作数都非零，则条件为真。|(A && B) 为假。
    | \|\| |称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。|(A \|\| B) 为真。
    | !|称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。|!(A && B) 为真。

- 位运算符
    位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

    |p|q|p & q|p \| q|p ^ q|
    |---|---|---|---|---|
    |0|0|0|0|0|
    |0|1|0|1|1|
    |1|1|1|1|0|
    |1|0|0|1|1|

- 赋值运算符

    |运算符|描述|实例|
    |---|---|---|
    |=|简单的赋值运算符，把右边操作数的值赋给左边操作数|C = A + B 将把 A + B 的值赋给 C|
    |+=|加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数|C += A 相当于 C = C + A|
    |-=|减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数|C -= A 相当于 C = C - A|
    |*=|乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数|C *= A 相当于 C = C * A|
    |/=|除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数|C /= A 相当于 C = C / A|
    |%=|求模且赋值运算符，求两个操作数的模赋值给左边操作数|C %= A 相当于 C = C % A|
    |<<=|左移且赋值运算符|C <<= 2 等同于 C = C << 2|
    |>>=|右移且赋值运算符|C >>= 2 等同于 C = C >> 2|
    |&=|按位与且赋值运算符|C &= 2 等同于 C = C & 2|
    |^=|按位异或且赋值运算符|C ^= 2 等同于 C = C ^ 2|
    |\|=|按位或且赋值运算符|C \|= 2 等同于 C = C \| 2|

- 杂项运算符

    |运算符|描述|
    |---|---|
    |sizeof|sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。|
    |Condition ? X : Y|条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。|
    |,|逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。|
    |.（点）和 ->（箭头）|成员运算符用于引用类、结构和共用体的成员。|
    |Cast|强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。|
    |&|指针运算符 & 返回变量的地址。例如 &a; 将给出变量的实际地址。|
    |*|指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。|

- 运算符优先级:

    |类别 |运算符 |结合性 |
    |---|---|---|
    |后缀 |() [] -> . ++ - - |从左到右 |
    |一元 |+ - ! ~ ++ - - (type)* & sizeof| 从右到左 |
    |乘除 |* / %|从左到右 |
    |加减 |+ - |从左到右 |
    |移位 |<< >> |从左到右 |
    |关系 |< <= > >= |从左到右 |
    |相等 |== != |从左到右 |
    |位与 AND| & |从左到右 |
    |位异或 XOR|^ |从左到右 |
    |位或 OR |\| |从左到右 |
    |逻辑与 AND| && |从左到右 |
    |逻辑或 OR| \|\| |从左到右 |
    |条件 |?: |从右到左 |
    |赋值 |= += -= *= /= %=>>= <<= &= ^= \|= |从右到左 |
    |逗号 |, |  |

## 7.循环和判断

循环类型：

|循环类型|描述|
|---|---|
|while 循环|当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。|
|for 循环|多次执行一个语句序列，简化管理循环变量的代码。|
|do...while 循环|除了它是在循环主体结尾测试条件外，其他与 while 语句类似。|
|嵌套循环|您可以在 while、for 或 do..while 循环内使用一个或多个循环。|

循环控制语句：

|控制语句|描述|
|---|---|
|break 语句|终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。|
|continue 语句|引起循环跳过主体的剩余部分，立即重新开始测试条件。|
|goto 语句|将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。|

判断语句
C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。

|语句|描述|
|---|---|
|if 语句|一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。|
|if...else 语句|一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。|
|嵌套 if 语句|您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。|
|switch 语句|一个 switch 语句允许测试一个变量等于多个值时的情况。|
|嵌套 switch 语句||

? : 运算符

## 8.函数

函数参数：

|调用类型|描述|
|---|---|
|传值调用|该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。|
|指针调用|该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。
|引用调用|该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际数。

默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。

Lambda 函数与表达式

C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。

Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。

Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:

`[capture](parameters)->return-type{body}`

例如：

`[](int x, int y){ return x < y ; }`

如果没有返回值可以表示为：

`[capture](parameters){body}`

例如：

`[]{ ++global_x; }`

在一个更为复杂的例子中，返回类型可以被明确的指定如下：

`[](int x, int y) -> int { int z = x + y; return z + x; }`

`[]      // 沒有定义任何变量。使用未定义变量会引发错误`

`[x, &y] // x以传值方式传入（默认），y以引用方式传入。`

`[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。`

`[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。`

`[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。`

`[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。`

另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

`[this]() { this->someFunc(); }();`

## 10.C++ 数字

在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。

C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。

为了利用这些函数，您需要引用数学头文件 <cmath>。

|序号|函数 | 描述|
|---|---|---|
|1|double cos(double);|该函数返回弧度角（double 型）的余弦。|
|2|double sin(double);|该函数返回弧度角（double 型）的正弦。|
|3|double tan(double);|该函数返回弧度角（double 型）的正切。|
|4|double log(double);|该函数返回参数的自然对数。|
|5|double pow(double, double);|假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。|
|6|double hypot(double, double);|该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。|
|7|double sqrt(double);|该函数返回参数的平方根。|
|8|int abs(int);|该函数返回整数的绝对值。|
|9|double fabs(double);|该函数返回任意一个十进制数的绝对值。|
|10|double floor(double);|该函数返回一个小于或等于传入参数的最大整数。|

C++ 随机数
在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用srand()函数。

## 11.数组

|概念|描述|
|---|---|
|多维数组|C++ 支持多维数组。多维数组最简单的形式是二维数组。|
|指向数组的指针|您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。|
|传递数组给函数|您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。|
|从函数返回数组|C++ 允许从函数返回数组。|

## 12.字符串

|序号|函数 | 目的|
|---|---|---|
|1|strcpy(s1, s2);|复制字符串 s2 到字符串 s1。|
|2|strcat(s1, s2);|连接字符串 s2 到字符串 s1 的末尾。|
|3|strlen(s1);|返回字符串 s1 的长度。|
|4|strcmp(s1, s2);|如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。|
|5|strchr(s1, ch);|返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。|
|6|strstr(s1, s2);|返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|

## 13.指针

> 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，
对其进行声明。指针变量声明的一般形式为：

    type *var-name;

在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

```C++
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

C++ 指针详解

|概念|描述|
|---|---|
|C++ Null 指针|C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。|
|C++ 指针的算术运算|可以对指针进行四种算术运算：++、--、+、-|
|C++ 指针 vs 数组|指针和数组之间有着密切的关系。|
|C++ 指针数组|可以定义用来存储指针的数组。|
|C++ 指向指针的指针|C++ 允许指向指针的指针。|
|C++ 传递指针给函数|通过引用或地址传递参数，使传递的参数在调用函数中被改变。|
|C++ 从函数返回指针|C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。|

## 14.引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

C++ 引用 vs 指针
引用很容易与指针混淆，它们之间有三个主要的不同：

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

|概念|描述|
|---|---|
|把引用作为参数|C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。|
|把引用作为返回值|可以从 C++ 函数中返回引用，就像返回其他数据类型一样。|

## 15.日期 & 时间

|序号|函数 | 描述|
|---|---|---|
|1|time_t time(time_t *time);|该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。|
|2|char *ctime(const time_t *time);|该返回一个表示当地时间的字符串指针，字符串形式 day month year  hours:minutes:seconds year\n\0。|
|3|struct tm *localtime(const time_t *time);|该函数返回一个指向表示本地时间的 tm 结构的指针。|
|4|clock_t clock(void);|该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。|
|5|char * asctime ( const struct tm * time );|该函数返回一个指向字符串的指针，字符串包含了time 所指向结构中存储的信息，返 回形式为：day month date hours:minutes:seconds \|\|year\n\0。|
|6|struct tm *gmtime(const time_t *time);|该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格   林尼治标准时间（GMT）表示。|
|7|time_t mktime(struct tm *time);|该函数返回日历时间，相当于 time 所指向结构中存储的时间。|
|8|double difftime ( time_t time2, time_t time1 );|该函数返回 time1 和 time2 之间相差的秒数。|
|9|size_t strftime();|该函数可用于格式化日期和时间为指定的格式。|

## 16.基本的输入输出

> C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。

I/O 库头文件

|头文件|函数和描述|
|---|---|
|\<iostream>|该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。|
|\<iomanip>|该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。|
|\<fstream>|该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。|

## 17.C++ 数据结构

定义结构

``` C++
struct type_name {
    member_type1 member_name1;
    member_type2 member_name2;
    member_type3 member_name3;
    .
    .
} object_names;
```

typedef 关键字
下面是一种更简单的定义结构的方式，您可以为创建的类型取一个"别名"。例如：

```C++
typedef struct Books
{
    char  title[50];
    char  author[50];
    char  subject[100];
    int   book_id;
}Books;
```

`typedef long int *pint32;`

## 18.类 & 对象

> C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。
类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。

类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。

```C++
class Box
{
    public:
        double length;   // 盒子的长度
        double breadth;  // 盒子的宽度
        double height;   // 盒子的高度
};
```

关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或protected

### 类成员函数:

> 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。

```C++
class Box
{
    public:
        double length;         // 长度
        double breadth;        // 宽度
        double height;         // 高度
        double getVolume(void);// 返回体积
};
```

成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。所以您可以按照如下方式定义 Volume() 函数：

```C++
class Box
{
    public:
        double length;         // 长度
        double breadth;        // 宽度
        double height;         // 高度
        double getVolume(void)
        {
            return length * breadth * height;
        }
};
```

您也可以在类的外部使用范围解析运算符 :: 定义该函数，如下所示：

```C++
double Box::getVolume(void)
{
    return length * breadth * height;
}
```

### 类访问修饰符

> 数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是
通过在类主体内部对各个区域标记 **public、private、protected** 来指定的。关键字 **public、private、protected**
称为访问修饰符。

```C++
class Base {
    public:
    // 公有成员
    protected:
    // 受保护成员
    private:
    // 私有成员
};
```

- 公有（public）成员:公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：
- 私有（private）成员:私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情下，类的所有成员都是私有的。
    > 实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数。
- 保护（protected）成员:保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

### 类的构造参数

```C++
public:
    void setLength( double len );
    double getLength( void );
    Line();  // 这是构造函数
    Line(double len);  // 这是构造函数
private:
    double length;
```

使用初始化列表来初始化字段

```C++
Line::Line( double len): length(len)
{
    cout << "Object is being created, length = " << len << endl;
}
```

两者等同

```C++
Line::Line( double len)
{
    length = len;
    cout << "Object is being created, length = " << len << endl;
}
```

假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化

```C++
C::C( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
```

### 类的析构函数

> 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

### C++ 拷贝构造函数

> 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：

```C++
classname (const classname &obj) {
   // 构造函数的主体
}
```

### 友元函数

> 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。
> 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。
如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。


```C++
class Box
{
    double width;

    public:
        double length;
        friend void printWidth( Box box );
        void setWidth( double wid );
};
```

`friend class ClassTwo;`

### 内联函数

> 通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。
> 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。
> 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。
> 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

### this 指针

> 在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。
> 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。

### 指向类的指针

> 一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。

### 类的静态成员

> 我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
> 静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。

## 继承
