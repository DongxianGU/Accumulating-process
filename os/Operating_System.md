# 操作系统

- [操作系统](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
    - [第一章 操作系统引论](#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA)
        - [操作系统的目标和作用](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BD%9C%E7%94%A8)
        - [操作系统的发展过程：](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B)
        - [操作系统的基本特性：](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7)
        - [操作系统的主要功能：](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD)
        - [OS结构设计](#os%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1)
    - [第二章 进程的描述和控制](#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6)
        - [前趋图和程序执行](#%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C)
        - [进程的描述](#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0)
        - [进程控制](#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6)
            - [操作系统内核](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8)
            - [进程](#%E8%BF%9B%E7%A8%8B)
        - [进程同步](#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5)
            - [硬件同步机制](#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6)
            - [信号量机制](#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6)
        - [管程机制](#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6)
        - [进程通信](#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1)
            - [共享存储器系统 Shared-Memory System](#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F-shared-memory-system)
            - [管道通信系统](#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F)
            - [消息传递系统](#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F)
            - [客户机-服务器系统](#%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F)
    - [第三章 处理调度与死锁](#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81)
    - [第四章 存储器管理](#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86)
    - [第五章 虚拟存储器](#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8)
    - [第六章 输入输出系统](#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F)
    - [第七章 文件管理](#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86)
    - [第八章 磁盘存储器的管理](#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86)
    - [第九章 操作系统接口](#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3)
    - [第十章 多处理机系统](#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E7%B3%BB%E7%BB%9F)
    - [第十一章 多媒体操作系统](#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%A4%9A%E5%AA%92%E4%BD%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
    - [保护和安全](#%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%AE%89%E5%85%A8)

## 第一章 操作系统引论

### 操作系统的目标和作用

在计算机系统上配置操作系统，其主要目标：方便性、有效性、可扩充性和开放性。

操作系统的作用：

1. 作为用户与计算机硬件系统之间的接口
2. 作为计算机系统资源的管理者
3. 实现了对计算机资源的抽象

### 操作系统的发展过程：

1. 未配置操作系统的计算机系统

   - 人工操作方式。缺点：用户独占全机；CPU等待人工操作
   - 脱机输入/输出（Off-Line I/O）方式。优点：减少了CPU的空闲时间；提高了I/O速度

     > 脱机I/O技术：事先将装有用户程序和数据的纸带装入纸带输入机，在外围机的控制下，把纸带上的数据输入到磁带上。

2. 单道批处理系统

   缺点：系统资源得不到充分利用。

3. 多道批处理系统（为了提高资源利用率和系统吞吐量）

   1. 基本概念

      在系统中，用户提交的作业先存放在外存上，并排成一个队列，成为“后备队列”。然后由作业调度按照一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。

   2. 优缺点

      1. 资源利用率高
      2. 系统吞吐量大
      3. 平均周转时间长
      4. 无交互能力

4. 分时系统(为了满足人机交互的需求)

   1. 用户需求主要体现在：人机交互；共享主机

   2. 关键问题：及时接受；及时处理

   3. 分时系统的特征：

      - 多路性

      - 独立性

      - 及时性

      - 交互性

5. 实时系统

   > 实时：表示”及时“
   > 实时计算：系统的正确性，不仅由计算机的逻辑结果来确定，而且还取决于产生结果的实践。

   实时系统的类型：

   1. 工业（武器）控制系统。
   2. 信息查询系统
   3. 多媒体系统
   4. 嵌入式系统

   实时任务的类型：

   1. 周期性任务和非周期性任务
   2. 硬实时任务和软实时任务

   实时系统和分时系统特征的比较：
   - 多路性
   - 独立性
   - 及时性
   - 交互性
   - 可靠性

6. 微机操作系统

   > 配置在微型机上的操作系统被称为微机操作系统

   1. 单用户单任务操作系统
        1. CP/M
        2. MS-DOS

   2. 单用户多任务操作系统
        1. Windows

   3. 多用户多任务操作系统
        UnixOS: Solaris OS;Linux OS

### 操作系统的基本特性：

- 并发 Concurrence
- 共享 Sharing
- 虚拟 Virtual
- 异步 Asynchronism

### 操作系统的主要功能：

1. 处理机管理功能

    - 进程控制
    - 进程同步
    - 进程通信
    - 调度：作业调度和进程调度

2. 存储器管理功能

    - 内存分配
    - 内存保护
    - 地址映射
    - 内存扩充
  
3. 设备管理功能

    - 缓冲管理
    - 设备分配
    - 设备处理
    > 设备管理的主要任务为完成用户进程提出的I/O请求，完成I/O操作；提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备

4. 文件管理功能

    - 文件存储的空间的管理
    - 目录管理
    - 文件读写管理和保护

5. 操作系统和用户之间的接口
    1. 用户接口
    2. 程序接口

6. 现代操作系统的新功能
    1. 系统安全
        - 认证技术
        - 密码技术
        - 访问控制技术
        - 反病毒技术

    2. 网络的功能和服务
        - 网络通信
        - 资源管理
        - 应用互操作

    3. 支持多媒体

### OS结构设计

1. 传统操作系统
    1. 无结构操作系统
    2. 模块化结构OS
        - 衡量模块独立性的两个标准：内聚性和耦合度
    3. 分层式结构OS

        优点：
        - 易保证系统的正确性
        - 易扩充性和易维护性

2. 客户/服务器模式
    > 三部分组成： 客户机、服务器和网络系统

3. 面向对象程序设计技术简介
4. 微内核OS结构

## 第二章 进程的描述和控制

### 前趋图和程序执行

> 前趋图：描述程序执行先后顺序。是一个有向无循环图（DAG(Direct Acyclic Graph)）

1. 程序的顺序执行
   > 通常一个程序由若干个个程序段组成，每个程序段完成特定的功能，它们在执行时，都需要按照某种先后次序顺序执行，当前一段程序执行完后，才运行后一程序段。

   程序顺序执行的特征：
    - 顺序性：指处理机严格按照程序规定的顺序执行，即每一操作必须在下一操作开始之前结束。
    - 封闭性：指程序在封闭的环境下运行，即程序运行时独占资源，资源的状态（除初始状态）只有本程序才能改变它，程序一旦执行，其执行结果不受外界因素影响。
    - 可再现性：指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿的执行，还是“停停走走”地执行，都可获得相同的结果

2. 程序的并发执行
   程序并发执行的特征：
    - 间断性：程序在并发执行时，由于它们共享资源，以及为完成同一项任务而相互合作，致使这些并发执行的程序之间形成了相互制约的关系。
    - 失去封闭性：某一程序运行时，其环境都必然会收到其他程序的影响。
    - 不可再现性：程序在并发执行时，由于失去了封闭性，也将导致其又失去了可再现性。

### 进程的描述

> PCB: Process Control Block 进程控制块，系统利用进程控制块来描述进程的基本情况和活动进程，从而控制和管理进程。
> 程序段、相关的数据段和PCB三部分构成了进程实体（进程映像）。

进程的定义：

1. 进程是程序的一次执行。
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
3. 进程具有独立功能的程序在一个数据结合上运行的过程，它是系统进行资源分配和调度的一个独立的单位。

进程的特征：

1. 动态性：进程是实质是进程实体的执行过程，因此，动态性就是进程的最基本的特征。
2. 并发性：是指多个进程实体同存于内存中，且能在一段时间内同时运行。
3. 独立性：在传统的OS中，独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。
4. 异步性：是指进程是按异步方式运行的，即按各自独立、不可预知的速度向前推进。

进程的基本状态：就绪状态、执行状态以及阻塞状态。

三种状态(以及两种常见状态)的转换：
![进程三态转换图](./imgs/进程转换图.png)

挂起操作和进程状态的转换

挂起操作：当该操作作用于某个进程时，该进程被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度。和挂起操作对应的操作是激活操作。

引入挂起操作的原因：

1. 终端用户的需要
2. 父进程请求
3. 负荷调节的需要
4. 操作系统的需要

在引入挂起原语Suspend和激活原语Active后，进程将可能发生一下几种状态的转化：

- 活动就绪->静止状态
- 活动阻塞->静止阻塞
- 静止就绪->活动就绪
- 静止阻塞->活动阻塞

在计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，称之为资源信息表或进程信息表，其中包含了资源或进程的标识、描述、状态等信息以及一批指针。

OS管理的这些数据结构一般分为四类：内存表、设备表、文件表和进程表，进程表又被称为进程控制块PCB。

PCB的作用：

- 作为独立运行基本单位的标志
- 能实现间断性运行方式
- 提供进程管理所需要的信息
- 提供进程调度所需要的信息
- 实现与其他进程的同步与通信

进程控制块中的信息主要包括四个方面

1. 进程标识符
    > 用于唯一的标志一个进程。通常有两种标识符
    - 外部标识符：为了方便用户（进程）对进程的访问。
    - 内部标识符：为了方便系统对进程的使用。
2. 处理机状态
    > 也称为处理机的上下文，主要是由处理机的各种寄存器的内容组成。
    - 通用寄存器:用于暂存信息。
    - 指令寄存器：存放了要访问下一条指令的地址
    - 程序状态字PSW：包含状态信息、如条件码、执行方式、中断屏蔽标志。
    - 用户栈指针：用于存放过程和系统调用参数及调用地址。
3. 进程调度信息
    - 进程状态
    - 进程优先级
    - 进程调度需要的其他信息
    - 事件：指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。
4. 进程控制信息：指用于进程控制必须的信息
    - 程序和数据的地址
    - 进程同步和通信机制
    - 资源清单：列出了进程在运行期间所需要的全部资源
    - 链接指针，给出了本进程所在队列中下一个进程的PCB的首地址。

进程控制块的组织方式：
> 在系统中会有多个PCB,为了有效的管理，应该用适当的方式组织这些PCB
- 线性方式，将所有PCB放入一张线性表，将表的首地址存在内存的一个专用区域中。
- 链接方式：将相同状态进程的PCB分别通过PCB的链接字链接成一个队列。
- 索引方式：系统根据所有进程状态的不同，建立几张索引表，将各索引表的首地址记录在内存的一些专用单元中。

### 进程控制

> 进程控制是进程管理的基本功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态，负责进程运行中的状态转换等功能。
> 进程控制一般由OS的内核中的原语来实现。

#### 操作系统内核

OS内核：通常将一些与硬件紧密关联的模块（如中断控制程序）、各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理、进程调度和许多模块所公用的一些基本操作），都安排在紧靠硬件的软件层次，将它们常驻内存，即通常被成为的OS内核。这样安排的目的在于：

- 便于对这些软件进行保护，防治遭受其他应用程序的破坏
- 提高OS的运行效率

同时为了防止OS本身及关键数据遭受应用程序有意无意的破坏，通常也将处理机的执行状态分为系统态和用户态两种：

- 系统态：又称管态，也称内核态。具有较高的特权，能够执行一切指令，访问所有的寄存器和存储区。传统的OS都在系统态运行。
- 用户态：又称目态。它具有较低特权的执行状态，仅能执行规定的指令，访问制定的寄存器和存储区。

一般情况下，应用程序只能在用户态下运行，不能执行OS指令及访问OS区域。

OS内核的功能：

- 支撑功能
  > 该功能是为了提供给OS其他众多模块所需要的一些基本功能，以便支撑这些模块工作。其中三种最基本的支撑功能是：中断处理、时钟管理和原语操作。
    - 中断处理：中断是内核最基本的功能。
    - 时钟管理：
    - 原语操作：所谓原语，就是由若干个指令组成，用于完成一定功能的一个过程。它和一般过程的区别是：它们是“原子操作”。原语在执行过程中不允许中断。原子操作在系统态下执行，常驻内存。
- 资源管理功能
    - 进程管理
    - 存储器管理
    - 设备管理

#### 进程

进程的层次结构：在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程。

引起创建进程的典型事件：

- 用户登录
- 作业调度
- 提供服务
- 应用请求：上述三种情况下，都是系统内核为用户创建新进程；而这类事件则是由用户进程自己创建新进程。

进程创建的过程：

1. 申请空白的PCB，为新进程申请获取唯一的数据标识符，并从PCB集合中索取一个PCD。
2. 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、IO设备和CPU时间等。
3. 初始化进程控制块：
    1. 初始化标志信息，将系统分配的标识符和父进程标识符填入新PCB中；
    2. 初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶；
    3. 初始化处理机控制信息，将进程的状态设置为就绪状态或静止就绪状态。
4. 如果进程就绪队列能够接纳新进程，就将新进程插入就绪队列。

引起进程终止的实践：

- 正常结束
- 异常结束：发生某种异常事件，程序无法继续运行
    常见的异常事件：越界错；保护错；非法指令；特权指令错；运行超时；等待超时；算术运算错；I/O故障
- 外界干预，是进程应外界的请求而终止运行
    - 操作员或操作系统干预
    - 父进程请求
    - 因父进程终止，指当父进程终止时，它的所有子进程都应当结束。

进程的终止过程：
> 系统中发生了要求终止进程的事件，OS调用进程终止原语
1. 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读取进程的状态。
2. 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；
3. 若该进程有子孙进程，还应当将其所有子孙进程都予以终止，防止它们成为不可控进程；
4. 将被终止进程所拥有的全部资源或者还给其父进程，或者还给系统；
5. 将被终止进程PCB从所在队列或链表中移出，等待其他程序来搜集信息。

引起进程阻塞和唤醒的事件：

- 向系统请求共享资源失败
- 等待某种操作的完成
- 新数据尚未到达。对于相互合作的进程，没有获得其他进程提供的数据，只有阻塞。
- 等待新任务的到达

进程阻塞过程：发生了上述的事件后，进程通过调用阻塞原语block将自己阻塞。阻塞是进程自身的一种主动行为。如果进程还处于执行状态，应先立即停止执行，把进程控制块中的现行状态由执行改为阻塞，并将PCB插入到阻塞队伍。

进程唤醒过程：当阻塞进程所期待的事件发生，则由有关进程调用唤醒原语wakeup，将等待该事件的进程唤醒。

进程的挂起：当系统中出现了引起进程挂起的事件时，OS利用挂起原语suspend将制定进程或处于阻塞状态的进程挂起。

进程的激活：当系统中发生激活进程的事件时，OS将利用激活原语active，将指定进程激活。

### 进程同步

单处理机系统中的进程同步机制：硬件同步机制、信号量机制、管程机制等。

进程同步机制的主要任务：是对多个相关进程在执行次序上进行协调，使得并发执行的主进程之间能按照一定的规则共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性。

在多道程序环境下，处于同一个系统中的多个进程，由于它们共享系统中的资源或为完成某一任务而相互合作，它们之间可能存在着以下两种形式的制约关系：

1. 间接相互制约关系
    > 多个程序并发执行，由于共享系统资源，如CPU、I/O设备等，致使在这些并发执行的程序之间形成相互制约的关系。
2. 直接相互制约关系
    > 某些应用程序，为了完成某个任务而建立了两个或多个进程。

临界资源：许多硬件资源如打印机、磁带机等都属于临界资源，诸进程间应采取互斥方式，实现对这种资源的共享。

临界区：人们把在每个进程中访问临界资源的那段代码称为临界区。

一个访问临界资源的循环进程描述如下：

    while(True)
    {
        进入区//检查是否能够访问临界资源
        临界区
        退出区//将临界区正被访问的标志恢复为为被访问的标志
        剩余区
    }

同步机制应该遵循的规则：

- 空闲让进
- 忙则等待
- 有限等待
- 让权等待

#### 硬件同步机制

1. 关中断
    > 关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，指导完成锁测试并上锁之后才能打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程或线程切换。

    缺点：

    - 滥用关中断权利可能导致严重后果
    - 关中断时间过长，会影响系统效率
    - 关中断方法不适用与多CPU系统
2. 利用Test-and-Set指令实现互斥
    > 借助一条硬件指令--“测试并建立”指令TS以实现互斥的方法。

    TS的一般描述如下

        boolean TS(boolean *lock)
        {
            boolean old;
            old = *lock;
            *lock = TRUE;
            return old;
        }

    这条指令可以当作一个函数过程，其执行过程是不可分割的，即是一条原语。当*lock=FALSE，表示该资源空闲；当\*locak=TRUE，表示资源正在被使用。

3. 利用Swap指令实现互斥
    > 该指令成为对换指令，在Intel 80x86 中又称XCHG指令，用于交换两个字的内容。

    处理过程如下：

        void swap(boolean *a,boolean *b)
        {
            boolean temp;
            temp = *a;
            *b = *a;
            *b = temp;
        }

    用对换指令可以简单有效的实现互斥，方法是为每个临界资源设置一个全局的布尔变量lock，其初值为false，在每个进程中再利用一个局部布尔变量key。利用swap指令实现进程互斥的循环过程如下：

        do{
            key = TRUE;
            do{
                swap(&lock,&key)
            }while(key!=FALSE);
            临界区操作；
            lock = FALSE;
            ...
        }while(TRUE);

#### 信号量机制

> 1965 年，荷兰学着Dijkstra提出的信号量机制是一种卓有成效的进程同步工具。现在信号量机制被广泛地应用于单处理机和多处理机系统以及计算机网络中。

1. 整型信号量
    > Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S,它和一般整型量不同，除初始化操作外，仅能通过两个标准的原子才做wait(S)和signal(S)来访问。很长时间，这两个操作被分别成为P、V操作。

    wait和signal操作可描述如下：

        wait(S){
            while(S<=0);
            S--;
        }
        signal(S){
            S++;
        }
2. 记录型信号量

    在整型信号量机制中的wait操作，只要信号量S<=0，就会不断的测试。没有遵循“让权等待”的准则，而是使进程处于“忙等”的状态，而记录型信号量机制不存在“忙等”现象的进程同步机制。

    除了一个代表资源数目的整型变量value，还增加一个进程链表指针list，用于链接访问同一临界资源所有等待进程。

    上述两个数据项可描述如下：

        typedef struct{
            int value;
            struct process_control_block *list;
        }semaphore;

    相应的wait(S)和signal(S)可描述如下：

        wait(semaphore *s){
            S->value--;
            if(S->value < 0>) block(S->list);
        }
        signal(semaphore *s){
            S->value++;
            if(S->value <=0) wakeup(S->list)
        }

3. AND型信号量

    上面的所述的进程问题针对的是多个并发进程共享一个临界资源的情况。但有些场合，是一个进程往往需要获得两个或更多的共享资源后才能执行其任务。

    AND同步机制的思想：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一次释放。只要尚有一个资源未能分配给进程，其他所有有可能为之分配的资源也不分配给它。亦即，多若干个临界资源的分配采用原子操作方式：要么把它所请求的资源全部分配到进程，要么一个不分配。

        Swait(S1,S2,...,Sn)
        {
            while(TRUE)
            {
                if(S1>=1 && ... && Sn>=1){
                    for(i=1;i<=n;i++) Si--;
                    break;
                }
                else
                {
                    place the process in the waiting queue associated with the
                    first Si found with Si<1,and set the program count of this
                    process to the beginning of Swait operation

                }
            }
        }

        Ssignal(S1,S2,...,Sn)
        {
            while(TRUE)
            {
                for(i=1;i<=n;i++){
                    Si++;
                    Remove all the process waiting in the queue associated with
                    Si into the ready queue.
                }
            }
        }

4. 信号量集

    前面的wait(S)和signal(S)操作仅能对信号量施以加1减1操作，意味着每次只能对某类临界资源进行一个单位的申请和释放。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。

    基于上述两点，可以对AND信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量，在一次PV原语操作中完成申请和释放。进程对信号量S
    i的测试值不再是1，而是资源分配的下限值ti,即要求Si>=ti,否者不予分配。一旦允许分配，进程对该资源的需求之为di,即表示资源占用量，进行Si=Si-di操作，而不是简单的Si=Si-1。由此形成一般化的“信号量集”机制。

### 管程机制

> 虽然信号量机制是一种既方便、又有效的进程同步机制，但要每个访问临界资源的进程都必须自备同步操作wait(S)和signal(S)。这就使大量的同步操作分散在各个进程中。这样不仅给系统带来了麻烦，还会因同步操作的使用不当而导致系统死锁。这样就产生了新的进程同步工具--管程（Monitors）

管程：代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程。

管程被请求和释放资源的进程所调用。

Hansan为管程所下的定义是：“一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据”

管程由四部分组成：

- 管程的名称
- 局部于管程的共享数据结构说明
- 对该数据结构进行操作的一组过程
- 对于局部于管程的共享数据设置初始值的语句

管程的语法描述如下：

    Monitor monitor_name{ /*管程名*/
        share variable declarations;/*共享变量说明*/
        cond declarations;          /*条件变量说明*/
        public:                     /*能够被进程调用的过程*/
            void P1(...)            /*对数据结构操作的过程*/
            {...}
            void P2(...)
            {...}
            ...
            void (...)
            {...}
            ...
            {                       /*管程主体*/
                initialization code;/*初始化代码*/
                ...
            }
    }

管程是一种程序设计语言的结构成分，从语言的角度看，管程具有一下特性：

- 模块化，即管程是一个基本程序单位，可以单独编译
- 抽象数据类型，指管程中不仅有数据，而且有对数据的操作
- 信息隐蔽，指管程中的数据只能被管程中的过程访问，这些过程也是在管程内部定义的，共管程外的进程调用，而管程中的数据结构以及过程（函数）的具体实现外部不可见。

管程和进程的不同：

- 虽然二者都定义了数据结构，但进程定义的是私有数据结构PCB,管程定义的是公共数据结构，如消息队列等
- 二者都存在对各自数据结构的操作，但进程是由顺序程序执行有关操作，而管程主要是进行同步操作和初始化操作
- 设置进程的目的在于实现系统的并发性，而管程的设置则是解决共享资源的互斥使用问题
- 进程通过调用管程中的过程对共享数据结构实行操作，该过程如通常的子程序一样被调用，因而管程是被动工作方式，进程则为主动工作方式
- 进程之间能够并发执行，而管程则不能与其调用者并发
- 进程具有动态性，由“创建”而诞生，由“撤销”而消亡，而管程则是操作系统中的一个资源管理模块，供进程调用。

在利用管程实现进程同步时，需要设置同步工具，如两个同步操作原语wait和signal。当某进程通过管程获取临界资源而未能满足时，管程便调用wait原语使该进程等待，并将其排在等待队列上，仅当另一进程访问完成并释放该资源之后，管程才又调用signal原语。唤醒等待队列中的队首进程。

除了同步工具是不够的，考虑一种情况，当一个进程调用了管程，在官陈中被挂起或被阻塞，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其他进程就无法进入管程，被迫长时间等待。为了解决这个问题，引入条件变量condition。

### 进程通信

进程通信是指进程之间的信息交换。

进程通信的类型，高级通信机制可归结为四大类：共享存储器系统、管道通信系统、消息传递系统以及客户机-服务器系统。

#### 共享存储器系统 Shared-Memory System

在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。分为一下两个类型：

- 基于共享数据结构的通信方式：要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。这种方式仅适用于传递相对少量的数据，通信效率低下，属于低级通信。
- 基于共享存储区的通信方式：为了传输大量的数据，在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读写交换信息，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS,这种通信属于高级通信。

#### 管道通信系统

> 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道；而接受管道输出的接受进程（即读进程）则从管道中接受数据。由于发送进程和接受进程是利用管道进行通信的，故又称为管道通信。

为了协调双方的通信，管道机制必须提供三方面协调能力：

- 互斥：即当一个进程正在对pipe进行读/写操作时，另一进程必须等待
- 同步：指当写进程把一定数量的数据写入pipe，便去睡眠等待，指导读进程取走数据后再把它唤醒。当读进程读取一空pipe时，也应睡眠等待，直至写进程将数据写入管道后才将之唤醒。
- 确定对方是否存在：只有确定了对方已存在时才能进行通信

#### 消息传递系统

在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息（message）为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。当前应用最广泛的一类进程间通信机制。例如：在计算机网络中，消息又称报文；在微内核操作系统中，微内核和服务器之间的通信无一例外是采用了消息传递机制；由于该机制能很好的支持多处理机系统、分布式系统和计算机网络，因而成为这些领域最主要的通信工具。

基于消息传递系统的通信方式属于高级通信方式，因其实现方式不同，可进一步分为两类：

- 直接通信方式，是指发送进程利用OS提供的发送原语，直接把消息发送给目标进程
- 间接通信方式：是指发送和接受进程，都通过共享中间实体（称为邮箱）的方式进行消息的发送和接受，完成进程的通信。

#### 客户机-服务器系统

前面的技术，虽然也应用于不同计算机间进程的双向通信，但客户机-服务器系统的通信机制，在网络环境的各种应用领域已经成为当前主流的通信实现机制，其主要的实现方法范围三类：套接字、远程过程调用（RPC）和远程方法调用。

1. 套接字 Socket
    > 套接字起源于20世纪70年代加州大学伯克利分校版本的UNIX(即BSD Unix)，是UNIX操作系统下的网络通信接口。

    一个套接字就是一个通信标识类型的数据结构，包括：
    1. 通信目的的地址
    2. 通信使用的端口号
    3. 通信网络的传输协议
    4. 进程所在的网络地址
    5. 针对客户或服务器程序提供的不同系统调用（或API函数）

    套接字是为客户/服务器模型而设计的，通常，套接字包括两类：

    - 基于文件型
        > 通信进程都运行在同一台机器的环境中，套接字是基于本地文件系统支持的，一个套接字关联到一个特殊的文件，通信双方通过这个文件的读写实现通信。
    - 基于网络型
        > 该类型通常采用非对称方式的通信，即发送者需要提供接受者的命名。

2. 远程过程调用和远程方法调用

    远程过程（函数）调用（Remote Procedure Call）是一个通信协议，用于通过网络连接的系统。该协议允许运行于一台主机（本地）系统上的进程调用另一台主义（远程）系统上的进程。如果设计面向对象编程，那么远程过程调用亦可称为远程方法调用。

    负责处理远程过程调用的进程有两个：一是本地客户进程，另一个是远程服务器进程，者两个进程通常也被称为网络守护进程，主要负责在网络间的消息传递，一般情况下，这两个进程都是处于阻塞状态，等待消息。

    为了使远程过程调用看上去和本地过程调用一样，即希望实现RPC的透明性，使得调用者感觉不到此次调用的过程是在其他主机（远程）上执行的，RPC引入一个存根（stub）的概念：
    在本地客户端，每个能够独立运行的远程过都拥有一个客户存根（client stubborｄ），本地进程调用远程过程实际是调用该过程相关联的存根；与此类似，在每个远程进程所在的服务器端，其所对应的实际可执行进程也存在一个服务器存根（stub）与其关联。本地客户存根和对应的远程服务器存根一般也是处于阻塞状态，等待消息。

    远程过程调用的主要步骤：

    1. 本地过程调用者以一般方式调用远程过程在本地关联的客户存根，传递相应的参数，然后将控制权转移给客户存根；
    2. 客户存根执行，完成包括过程名和调用参数等信息的消息建立，将控制权转移给本地客户进程；
    3. 本地客户进程完成与服务器的消息传递，将消息发送到远程服务器进程；
    4. 远程服务器进程接受消息后转入执行，并根据其中的远程过程名找到对应的服务器存根，将消息转给该存根；
    5. 该服务器存根接到消息后，由阻塞状态转入执行状态，拆开消息从中取出过程调用的参数，然后以一般方式调用服务器上关联的进程；
    6. 在服务器端远程过程运行完毕后，将结果返回与之关联的服务器存根；
    7. 该服务器存根获得控制权运行，将结果打包为消息，并将控制权转移给远程服务器进程；
    8. 远程服务器进程将消息发送回客户端；
    9. 本地客户进程接受到消息后，根据其中的过程名将消息存入关联的客户存根，在将控制权转移给客户存根；
    10. 客户存根从消息中取出结果，返回给本地调用进程，完成控制权的转移。

    上述过程的主要作用在于：将客户过程的本地调用转化为客户存根，再转化为服务器过程的本地调用，对于客户与服务器来说，它们的中间步骤是不可见的。

## 第三章 处理调度与死锁

## 第四章 存储器管理

## 第五章 虚拟存储器

## 第六章 输入输出系统

## 第七章 文件管理

## 第八章 磁盘存储器的管理

## 第九章 操作系统接口

## 第十章 多处理机系统

## 第十一章 多媒体操作系统

## 保护和安全
